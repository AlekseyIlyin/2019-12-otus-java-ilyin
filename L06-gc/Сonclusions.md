###### Сравнение сборщиков: Parallel, Serial, G1GC

*Исследования проводились с параметрами виртуальной машины*:<p>
-Xms4096m -Xmx4096m -XX:+HeapDumpOnOutOfMemoryError и последовательно с использованием каждого из трёх сборщиков
<p>Алгоритм постоянно наращивал используемый объём памяти под List с ссылками на объекты, предыдущий List "скармливался" сборщику мусора.

*Parallel*
<p>Пока объём памяти использовался около 25% сборщик прекрасно справлялся, тратя в среднем на сборку Young около 0.25 ms, после превышения используемого объёма более 75% время сборки резко увеличилось до 730 ms, затем стали запускаться другие алгоритмы сборки, общее время работы алгоритма до падения с переполнением памяти составило: 04:55

*Serial*
<p>Пока объём памяти использовался около 25% сборщик прекрасно справлялся, тратя в среднем на сборку Young около 0.5 ms, после превышения используемого объёма более 75% время сборки резко увеличилось до 400 ms, попеременно запускались только два алгоритма сборки: Pause Young и Pause Full, общее время работы алгоритма до падения с переполнением памяти составило: 01:45

*G1GC*
<p>По логам видно, что сборщик использует многопоточность и различные алгоритмы сборки
общее время работы алгоритма до падения с переполнением памяти составило: 02:29

#####Вывод: Для данного алгоритма самый эффективным сборщиком оказался Serial, он позволил выполняться алгоритму быстрее 01:45.