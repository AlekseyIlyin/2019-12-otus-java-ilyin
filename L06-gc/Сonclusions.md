###### Сравнение сборщиков: Parallel, Serial, G1GC

*Исследования проводились с параметрами виртуальной машины*:<p>
-Xms4096m -Xmx4096m -XX:+HeapDumpOnOutOfMemoryError и последовательно с использованием каждого из трёх сборщиков
<p>Алгоритм постоянно наращивал используемый объём памяти под List с ссылками на объекты, предыдущий List "скармливался" сборщику мусора.
<p>Для чистоты тестирования другие процессы не запускались.
<p>Для анализа использования конкуренции времени потраченного JVM на сборку и выполнение алгоритма решил посчитать соотношение используемого времени на работу алгоритма и сборщика, назвал его ниже "Коэффициент конкуренции", чем он больше - тем больше времени тратила JVM на выполнение алгоритма а не на сборку. 

*Parallel*
<p>Пока объём памяти использовался около 25% сборщик прекрасно справлялся, тратя в среднем на сборку Young около 0.25 ms, после превышения используемого объёма более 75% время сборки резко увеличилось до 730 ms, затем стали запускаться другие алгоритмы сборки, общее время на сборку мусора составило 199 секунд, общее время работы алгоритма до падения с переполнением памяти составило: 04:55 (273 секунды), "Коэффициент конкуренции" - (273 - 199) / 199 = 0,37  

*Serial*
<p>Пока объём памяти использовался около 25% сборщик прекрасно справлялся, тратя в среднем на сборку Young около 0.5 ms, после превышения используемого объёма более 75% время сборки резко увеличилось до 400 ms, попеременно запускались только два алгоритма сборки: Pause Young и Pause Full, общее время на сборку мусора составило 29 секунд, общее время работы алгоритма до падения с переполнением памяти составило: 01:45 (87 секунд), "Коэффициент конкуренции" - (87 - 29) / 29 = 2   

*G1GC*
<p>По логам видно, что сборщик использует многопоточность и различные алгоритмы сборки
общее время работы алгоритма до падения с переполнением памяти составило: 02:29

#####Вывод: Для данного алгоритма самый эффективным сборщиком оказался Serial, он позволил выполняться алгоритму быстрее - 01:45. Потраченное время на сборку мусора до падения JVM от нехватка памяти так же оказалось на стороне Serial, оно составило 29 секунд в то время как Parallel потратил на сборку 199 секунд. "Коэффициент конкуренции" описанный выше так же оказался на стороне Serial.   